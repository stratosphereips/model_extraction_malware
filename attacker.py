import lightgbm as lgb
from model import create_dnn, create_dnn2
import tensorflow as tf
import joblib
import abc

# This is optional and can also be called from the command line
from sklearnex import patch_sklearn
patch_sklearn()
from sklearn import svm

class AbstractAttacker(abc.ABC):
    @abc.abstractmethod
    def __init__(self):
        pass

    @abc.abstractmethod
    def __call__(self, X):
        raise NotImplementedError

    @abc.abstractmethod
    def train_model(self, X, y, X_val, y_val):
        raise NotImplementedError
    
    @abc.abstractmethod
    def save_model(self):
        raise NotImplementedError


class LGBAttacker(AbstractAttacker):
    def __init__(self, seed=42):
        self.lgb_params = {
            "boosting_type" : "gbdt",
            "objective" : "binary",
            "learning_rate" : 0.05,
            "num_leaves": 2048,
            "max_depth" : 15,
            "min_child_samples": 30,
            "verbose": -1,
            "seed": seed
        }
        self.model = None

    def train_model(self, X, y, X_val, y_val, boosting_rounds=100, early_stopping=15):
        train_data = lgb.Dataset(X, label=y)
        self.val_data = lgb.Dataset(X_val, y_val)
        self.model = lgb.train(self.lgb_params, train_data,
                    num_boost_round=boosting_rounds,
                    valid_sets=[self.val_data],
                    verbose_eval=False,
                    early_stopping_rounds=early_stopping
                    )                
    
    def __call__(self, X):
        return self.model.predict(X)

    def save_model(self, path):
        self.model.save_model(path+".txt")


class KerasAttacker(AbstractAttacker):
    def __init__(self, early_stopping=30, seed=42, mc=False):

        self.model = create_dnn(seed=seed, mc=mc)
        self.checkpoint_filepath = '/tmp/checkpoint'
        self.model_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(
            filepath=self.checkpoint_filepath,
            save_weights_only=True,
            monitor='val_accuracy',
            mode='max',
            save_best_only=True)

        self.early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=early_stopping)

    def train_model(self, X, y, X_val, y_val, num_epochs):
        
        self.model.fit(X, y,
            batch_size=128, 
            epochs=num_epochs, 
            validation_data=(X_val, y_val),
            callbacks=[self.model_checkpoint_callback, self.early_stopping])   

        # Load the best weights after training
        self.model.load_weights(self.checkpoint_filepath)       
    
    def __call__(self, X):        
        return self.model.predict(X)

    def save_model(self, path):
        self.model.save(path+".h5")

class KerasDualAttacker(AbstractAttacker):
    def __init__(self, early_stopping=30, seed=42, mc=False):

        self.model = create_dnn2(seed=seed, mc=mc)

        self.checkpoint_filepath = '/tmp/checkpoint2'
        self.model_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(
            filepath=self.checkpoint_filepath,
            save_weights_only=True,
            monitor='val_accuracy',
            mode='max',
            save_best_only=True)

        self.early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=early_stopping)

    def train_model(self, X, y, y_true, X_val, y_val, y_val_true, num_epochs):
        
        self.model.fit((X, y_true), y,
            batch_size=128, 
            epochs=num_epochs, 
            validation_data=((X_val, y_val_true), y_val),
            callbacks=[self.model_checkpoint_callback, self.early_stopping])  
        
        self.model.load_weights(self.checkpoint_filepath)          
    
    def __call__(self, X, y_true):
        return self.model.predict((X, y_true))

    def save_model(self, path):
        self.model.save(path+".h5")


class SVMAttacker(AbstractAttacker):
    def __init__(self, seed=42, max_iter=1000):
        self.model = svm.SVC(C=10., 
                    kernel='linear',
                    max_iter=max_iter, 
                    random_state=seed, 
                    probability=True)

    def train_model(self, X, y):
        self.model.fit(X, y)
        print(f"SVM was fitted properly: {self.model.fit_status_}")

    def __call__(self, X):
        return self.model.predict_proba(X)[:, 1]

    def save_model(self, path):
        joblib.dump(self.model, path+".joblib")
        